// OPTIONAL: Additional UI Controls for Fine-Tuning Boundary Behavior
// These could be added to the UI if you want to allow runtime adjustment of boundary collision behavior

// In GLWindow.h, add these member variables:
private:
    float m_boundaryReflectionStrength = 0.8f;    // Current: 0.8, was: 5.0
    float m_boundaryAvoidanceStrength = 0.2f;     // Current: 0.2
    float m_boundaryAvoidanceZone = 0.9f;         // Current: 0.9 (90% of boundary)

// Add these methods to GLWindow class:
public:
    void setBoundaryReflectionStrength(double strength);
    void setBoundaryAvoidanceStrength(double strength);
    void setBoundaryAvoidanceZone(double zone);

// Implementation in GLWindow.cpp:
void GLWindow::setBoundaryReflectionStrength(double strength)
{
    m_boundaryReflectionStrength = static_cast<float>(strength);
}

void GLWindow::setBoundaryAvoidanceStrength(double strength)
{
    m_boundaryAvoidanceStrength = static_cast<float>(strength);
}

void GLWindow::setBoundaryAvoidanceZone(double zone)
{
    m_boundaryAvoidanceZone = static_cast<float>(zone);
}

// Then modify the boundary collision code in flock.cpp to use these variables:
// Replace the hardcoded values:
// s->setVelocity(s->getNextPosition() - d * 0.8);
// With:
// s->setVelocity(s->getNextPosition() - d * m_boundaryReflectionStrength);

// And:
// Vector avoidanceForce = m_bbox->getNormalArray()[i] * (avoidanceStrength * 0.2f);
// With:
// Vector avoidanceForce = m_bbox->getNormalArray()[i] * (avoidanceStrength * m_boundaryAvoidanceStrength);

// And:
// GLfloat avoidanceZone = ext[i] * 0.9f;
// With:
// GLfloat avoidanceZone = ext[i] * m_boundaryAvoidanceZone;

// You could then add these controls to the UI:
// - "Boundary Reflection Strength" slider (range: 0.1 to 2.0, default: 0.8)
// - "Boundary Avoidance Strength" slider (range: 0.0 to 1.0, default: 0.2)
// - "Boundary Avoidance Zone" slider (range: 0.5 to 0.95, default: 0.9)

// This would allow real-time tuning of boundary behavior without recompiling.
